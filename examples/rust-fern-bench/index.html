<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <title>rust-fern-bench</title>
</head>
<body>
    <canvas id="demo" style="width: 100%; height: 100%;"></canvas>

    <script src="../deps/three.min.js"></script>
    <script src="../deps/OrbitControls.js"></script>
    <script src="../deps/WebVR.js"></script>
    <script src="../deps/Sky.js"></script>
    <script src="../deps/stats.min.js"></script>

    <script src="../../dist/threelet.min.js"></script>
    <script src="../templates/plane-app.js"></script>
    <script src="../templates/example-utils.js"></script>

    <script type="module">
    import { default as UtilsDev } from "../../src/Utils.js";
    // console.log('UtilsDev:', UtilsDev);

    class Demo extends Threelet.PlaneApp {
        // override
        onCreate(params) {
            super.onCreate(params);

            // no stroking in this app; so enable rotate by mouse
            this.controls.enableRotate = true;

            // 0: fps, 1: ms, 2: mb, 3+: custom
            this.setup('mod-stats', window.Stats, {panelType: 2});

            this.reIni = -0.15;
            this.imIni = 0.65;
            this.jsetData = {
                mod: null,
                re: this.reIni,
                im: this.imIni,
            };

            (async () => {
                const mod = await Threelet.Utils.loadWasmBindgen(
                    './fern', await import(`./fern.export.js`));
                // console.log('fern - mod, wasm:', mod, mod.wasm);
                // this.onWasmReady(mod);

                this.jsetData.mod = mod;
                this.updateJset();
            })();
        }

        onWasmReady(mod) {
            // const maxIter = 1; // -> 1*3*16 byte
            // const maxIter = 1024*1024*10; // -> 480 mb
            // const maxIter = 1024*1024; // -> 48 mb
            // const maxIter = 1000*1000; // ~ 48 mb !!!! use for bench
            const maxIter = 1000*100; // ~ 4.8 mb !!!! dev
            // const maxIter = 1024*10; // -> 480 kb

            const numFerns = 4;

            const statsRust = Demo.benchFernRust(maxIter, numFerns, mod);
            // this.scene.add(statsRust);

            const statsJs = Demo.benchFernJs(maxIter, numFerns);
            statsJs.position.z -= 0.25;
            this.scene.add(statsJs);

            this.scene.add(statsRust);
        }

        static benchFernRust(maxIter, numFerns, mod) {
            const numVerts = maxIter * 3; // 1 iter <-> 1 triangle

            const loggerAlloc = UtilsDev.createLogger({mute: false});
            loggerAlloc.log('begin: rust verts alloc');
            const vertsBuf = new mod.VertsBuffer(numVerts);
            loggerAlloc.log('end: rust verts alloc <<<<');

            const logger = UtilsDev.createLogger();
            for (let i = 0; i < numFerns; i++) {
                logger.log('begin: rust verts compute');
                // vertsBuf.compute_one_triangle(); // debug
                vertsBuf.compute_fern();
                logger.log('end: rust verts compute <<<<');
            }
            // console.log('logger:', logger);

            const samples = logger.grep('end:').splits;

            let positions = vertsBuf.get_positions();
            let colors = vertsBuf.get_colors();
            console.log('positions/colors len:', positions.length, colors.length);

            if (numVerts === 3) { // debug
                console.log('positions:', positions);
                console.log('colors:', colors);
                vertsBuf.test_hash();
            }

            const stats = this.createStats(positions, colors, samples);
            // *** vertsToMesh() has already created buffer attributes
            // using the positions/colors array.
            // so we're done with these arrays.
            // ***

            // https://stackoverflow.com/questions/43918027/what-is-the-best-way-to-free-up-memory-from-a-typedarray-in-javascript
            positions = null; // just in case
            colors = null; // just in case

            vertsBuf.free();

            return stats;
        }

        static benchFernJs(maxIter, numFerns) {
            const loggerAlloc = UtilsDev.createLogger({mute: false});
            loggerAlloc.log('begin: js verts alloc');
            const positions = new Float32Array(maxIter * 9);
            const colors = new Uint8Array(maxIter * 12);
            loggerAlloc.log('end: js verts alloc <<<<');
            console.log('positions/colors len:', positions.length, colors.length);

            const logger = UtilsDev.createLogger();
            for (let i = 0; i < numFerns; i++) {
                logger.log('begin: js verts compute');
                this.computeFern(positions, colors, maxIter);
                logger.log('end: js verts compute <<<<');
            }
            // console.log('logger:', logger);

            // const samples = new Float32Array(10).map(_val => 0.5 + 0.2 * (Math.random() - 0.5)); // test
            const samples = logger.grep('end:').splits;
            // console.log('samples:', samples);

            return this.createStats(positions, colors, samples);
        }

        static createStats(positions, colors, samples) {
            const fern = UtilsDev.createBufferGeometryMesh(positions, colors, 0.2);
            fern.position.set(1, 0, 0); // show only the last one computed

            const resultGroup = new THREE.Group();
            resultGroup.add(fern,
                Threelet.ExampleUtils.createStatsFromSamples(samples),
                Threelet.ExampleUtils.createSamplesObject(samples));
            return resultGroup;
        }

        static computeFern(positions, colors, maxIter) {
            // https://en.wikipedia.org/wiki/Barnsley_fern
            const f1 = [0, 0, 0, 0.16, 0, 0, 0.01]; // Stem
            const f2 = [0.85, 0.04, -0.04, 0.85, 0, 1.60, 0.85]; // Successively smaller leaflets
            const f3 = [0.20, -0.26, 0.23, 0.22, 0, 1.60, 0.07]; // Largest left-hand leaflet
            const f4 = [-0.15, 0.28, 0.26, 0.24, 0, 0.44, 0.07]; // Largest right-hand leaflet
            //---- a mutant
            // const f1 = [0, 0, 0, 0.25, 0, -0.4, 0.02];
            // const f2 = [0.95, 0.005, -0.005, 0.93, -0.002, 0.5, 0.84];
            // const f3 = [0.035, -0.2, 0.16, 0.04, -0.09, 0.02, 0.07];
            // const f4 = [-0.04, 0.2, 0.16, 0.04, 0.083, 0.12, 0.07];

            const probAcc1 = f1[6];
            const probAcc2 = f1[6] + f2[6];
            const probAcc3 = f1[6] + f2[6] + f3[6];
            const fractalUpdate = (x, y, prob) => {
                let cs;
                if (prob < probAcc1) {
                    cs = f1;
                } else if (prob < probAcc2) {
                    cs = f2;
                } else if (prob < probAcc3) {
                    cs = f3;
                } else {
                    cs = f4;
                }
                return [
                    cs[0] * x + cs[1] * y + cs[4],
                    cs[2] * x + cs[3] * y + cs[5],
                ];
            };

            const triWidth = 0.02;
            const zVariation = 0.01;
            const baseColor = [255, 255, 0, 100];
            for (let i = 0, x = 0, y = 0, z = 0; i < maxIter; i++) {
                // const prob = 0.5;
                const prob = Math.random();
                z = zVariation * prob;

                positions[9*i] = x;
                positions[9*i+1] = y;
                positions[9*i+2] = z;
                positions[9*i+3] = x + triWidth;
                positions[9*i+4] = y;
                positions[9*i+5] = z;
                positions[9*i+6] = x;
                positions[9*i+7] = y + triWidth;
                positions[9*i+8] = z;

                colors[12*i] = baseColor[0];
                colors[12*i+1] = baseColor[1];
                colors[12*i+2] = baseColor[2];
                colors[12*i+3] = baseColor[3];
                colors[12*i+4] = baseColor[0];
                colors[12*i+5] = baseColor[1];
                colors[12*i+6] = baseColor[2];
                colors[12*i+7] = baseColor[3];
                colors[12*i+8] = baseColor[0];
                colors[12*i+9] = baseColor[1];
                colors[12*i+10] = baseColor[2];
                colors[12*i+11] = baseColor[3];

                [x, y] = fractalUpdate(x, y, prob);
            }
        }

        static testWasmMemBuffer(mod) {
            // https://github.com/rustwasm/wasm-bindgen/issues/1079
            // https://github.com/rustwasm/wasm-bindgen/issues/1643

            // let buffer = new WasmMemBuffer(100000, array => {
            let buffer = new mod.WasmMemBuffer(10, array => {
              // "array" wraps a piece of wasm memory. Fill it with some values.
                for (let i = 0; i < array.length; i++) {
                    array[i] = Math.floor(Math.random() * 256);
                }
                console.log('array:', array);
                console.log('sum of array:', array.reduce((a, b) => a + b, 0));
            });
            console.log('buffer:', buffer);
            let hash = mod.compute_buffer_hash(buffer); // No buffer copy when passing this argument. Yay!
            buffer.free();
            console.log('hash:', hash);
        }

        //===================================================================

        updateJset() {
            console.log('@@ this.jsetData:', this.jsetData);
            const {mod, re, im} = this.jsetData;
            const ctx = this.planeCtx;

            if (ctx && mod) {
                Demo.drawC(ctx, re, im);
                // mod.draw(ctx, 256, 256, 0.005*2.4, re, im);
                this.setPlaneNeedsUpdate(true);
            }
        }

        static drawC(ctx, re, im) {
            // TODO fancy refactored method to skip this brute hardcoding...

            //-------- 3rd row
            ctx.fillStyle = '#222';
            ctx.fillRect(0*64, 3*32, 64, 32);
            ctx.fillRect(1*64, 3*32, 64, 32);
            ctx.fillStyle = '#444444';
            ctx.fillRect(2*64, 3*32, 64, 32);
            ctx.fillStyle = '#222';
            ctx.fillRect(3*64, 3*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- fg
            ctx.font = '13px monospace';
            // ctx.fillText(`Re(C): ${re.toFixed(2)}`, 0*64+8, 3*32+20);
            ctx.fillText(`benchFernRust()`, 0*64+8, 3*32+20);
            // ctx.fillText('', 1*64+8, 3*32+20);
            ctx.fillText('Start', 2*64+8, 3*32+20);
            ctx.fillText(`ave: 0.000 (s)  std: 0.000 (s)`, 3*64+8, 3*32+20);
            //-------- 4th row
            ctx.fillStyle = '#222';
            ctx.fillRect(0*64, 4*32, 64, 32);
            ctx.fillRect(1*64, 4*32, 64, 32);
            ctx.fillStyle = '#444444';
            ctx.fillRect(2*64, 4*32, 64, 32);
            ctx.fillStyle = '#222';
            ctx.fillRect(3*64, 4*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- fg
            ctx.font = '13px monospace';
            // ctx.fillText(`Im(C): ${im.toFixed(2)}`, 0*64+8, 4*32+20);
            ctx.fillText(`benchFernJs()`, 0*64+8, 4*32+20);
            // ctx.fillText('', 1*64+8, 4*32+20);
            ctx.fillText('Start', 2*64+8, 4*32+20);
            ctx.fillText(`ave: 0.000 (s)  std: 0.000 (s)`, 3*64+8, 4*32+20);
        }

        // impl
        drawTitle(ctx) {
            ctx.fillStyle = '#cccccc';
            ctx.font = '18px monospace';
            ctx.fillText('WIP: 🦀rust-fern-bench', 16, 32+8);
        }

        // impl
        drawCommands(ctx) {
            // TODO fancy refactored method to skip this brute hardcoding...

            //-------- 2nd row
            ctx.fillStyle = '#444444';
            // ctx.fillRect(0*64, 2*32, 64, 32);
            // ctx.fillRect(1*64, 2*32, 64, 32);
            // ctx.fillRect(2*64, 2*32, 64, 32);
            // ctx.fillRect(3*64, 2*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- fg
            ctx.font = '13px monospace';
            ctx.fillText('Compute fractal with 1,000,000 triangles; 10 times per bench', 0*64+8, 2*32+20);
            // ctx.fillText('', 1*64+8, 2*32+20);
            // ctx.fillText('', 2*64+8, 2*32+20);
            // ctx.fillText('', 3*64+8, 2*32+20);

            //-------- 5th row
            ctx.fillStyle = '#444444';
            // ctx.fillRect(0*64, 5*32, 64, 32);
            ctx.fillRect(1*64, 5*32, 64, 32);
            // ctx.fillRect(2*64, 5*32, 64, 32);
            // ctx.fillRect(3*64, 5*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- fg
            ctx.font = '13px monospace';
            // ctx.fillText('', 0*64+8, 5*32+20);
            ctx.fillText('Reset????', 1*64+8, 5*32+20);
            // ctx.fillText('', 2*64+8, 5*32+20);
            // ctx.fillText('', 3*64+8, 5*32+20);

            //-------- 7th row
            ctx.fillStyle = '#444444';
            ctx.fillRect(0*64, 7*32, 64, 32);
            ctx.fillRect(1*64, 7*32, 64, 32);
            ctx.fillStyle = '#cccccc'; //---- fg
            ctx.fillText('source code', 0*64+8, 7*32+20);
        }

        updateMarker(what, row, col, width=1) {
            const marker = this.getMarker(
                what.startsWith('cmd-') ? 'commandMarker' : 'invalid');
            if (! marker) return;

            // note: position is relative to the 'selector' group
            marker.position.set(-2+0.25*col, 0.125+0.25*(3-row), 0.005);
            marker.scale.set(width, 1, 1);
            marker.visible = true;

            if (what.startsWith('cmd-')) {
                setTimeout(() => { marker.visible = false; }, 500);
            }
            this.render();
        }

        // impl
        onLeftPlaneClicked(faceIndex) {
            console.log('faceIndex:', faceIndex);
            const _fn = (what, row, col, width) => {
                this.onSelect(what);
                this.updateMarker(what, row, col, width);
            };
            switch (faceIndex) {
                case 52: case 53: _fn('cmd-bench-rust', 3, 5, 1); break;
                case 68: case 69: _fn('cmd-bench-js', 4, 5, 1); break;
                case 82: case 83: _fn('cmd-reset', 5, 3, 1); break;
                case 112: case 113: case 114: case 115: _fn('cmd-src', 7, 2, 2); break;
                default: console.log('@@ nop');
            }
        }

        onSelect(what) {
            if (what.startsWith('cmd-')) {
                const command = what.replace('cmd-', '');
                switch (command) {
                    case 'bench-rust': {
                        // console.log('re-');
                        this.jsetData.re -= 0.01;
                        this.updateJset();
                        break;
                    }
                    case 'bench-js': {
                        // console.log('im-');
                        this.jsetData.im -= 0.01;
                        this.updateJset();
                        break;
                    }
                    case 'reset': {
                        // console.log('reset');
                        // this.clearPaintArea('#0ff');
                        this.jsetData.re = this.reIni;
                        this.jsetData.im = this.imIni;
                        this.updateJset();
                        break;
                    }
                    case 'src': {
                        // console.log('src');
                        document.location.href = 'https://github.com/w3reality/threelet/tree/master/examples/rust-fern-bench';
                        break;
                    }
                    default: console.log('@@ unknown command:', command);
                }
            } else {
                console.log('@@ onSelect(): nop');
            }
        }
    }

    const demo = new Demo({
        canvas: document.getElementById("demo"),
        // optAxes: false,
        debugCube: true,
        paintAreaColor: '#222',
    });
    demo.updateLoop(1);

    </script>
</body>
</html>
