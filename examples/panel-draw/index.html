<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <title>panel-draw</title>
</head>
<body>
    <canvas id="viewer" style="width: 100%; height: 100%;"></canvas>

    <script src="../deps/stats.min.js"></script>
    <script src="../deps/three.min.js"></script>
    <!-- <script src="../deps/OrbitControls.js"></script> -->
    <script src="../deps/WebVR.js"></script>
    <script src="../deps/signature_pad.min.js"></script>

    <script src="../../dist/threelet.min.js"></script>
    <!-- ==== prod/dev ==== -->
    <script type="module">
    // import Threelet from '../../src/index.js';

    class Viewer extends Threelet {
        onCreate(params) {
            // this.setup('mod-controls', THREE.OrbitControls);
            this.setup('mod-stats', window.Stats, {panelType: 0}); // 0: fps, 1: ms, 2: mb, 3+: custom
            this.setup('mod-webvr', window.WEBVR);

            const _planeCanvas = Viewer.createPlaneCanvas();
            this.selector = Viewer.createSelector(_planeCanvas);

            const group = this.getInteractiveGroup();
            group.add(this.selector); // for ray not passing ghrough the selector surface
            this.scene.add(group);
            if (Threelet.isVrSupported()) group.position.z -= 2.5;

            this.scene.add(Threelet.Utils.createTestHemisphereLight());
            this.scene.add(Threelet.Utils.createTestDirectionalLight());
            this.scene.add(new THREE.GridHelper(10, 20));

            const [_sigPad, _sigCanvas] = Viewer.createSigObjects();
            const _plane = this.selector.getObjectByName('plane');
            this.setupMouseInterface(
                (x, y) => { // onClick
                    const isec = this.raycastFromMouse(x, y, [_plane], false);
                    if (isec) {
                        // console.log('@@ isec.faceIndex:', isec.faceIndex);
                        this.onPlaneClicked(isec.faceIndex);
                    }
                },
                (x, y) => { // onDrag
                    const isec = this.raycastFromMouse(x, y, [_plane], false);
                    if (! isec) return;

                    // console.log('@@ isec.point:', isec.point);
                    // x,y:
                    // -2,2    0,2    2,2
                    //     left   right
                    // -2,0    0,0    2,0
                    if (isec.point.x > 0) { // in right square
                        // TODO x, y --> data !!!!!!!!
                        const penColor = 'rgb(0, 200, 0)';
                        const dataTest = [
                           [{x: 119, y: 45, color: penColor}, // stroke 0
                           {x: 128, y: 43, color: penColor},
                           {x: 136, y: 42, color: penColor},
                           {x: 141, y: 42, color: penColor},
                           {x: 128, y: 43, color: penColor}],
                           [{x: 119, y: 125, color: penColor}, // stroke 1
                           {x: 128, y: 123, color: penColor},
                           {x: 136, y: 122, color: penColor},
                           {x: 141, y: 122, color: penColor},
                           {x: 128, y: 123, color: penColor}],
                        ];
                        _sigPad.fromData(dataTest);
                    }
                });

            this._planeClickStart = [-1, -1]; // faceIndex per controller i
            this.on('vr-trigger-press-start', (i) => {
                const isect = this.raycastFromController(i, [_plane], false)[0];
                if (isect) {
                    console.log('@@ click-start');
                    this._planeClickStart[i] = isect.faceIndex;
                } else {
                    this._planeClickStart[i] = -1;
                }
            });
            this.on('vr-trigger-press-end', (i) => {
                const isect = this.raycastFromController(i, [_plane], false)[0];
                if (isect) {
                    const faceIndex = isect.faceIndex;
                    console.log('@@ click-end; faceIndex:', faceIndex);
                    if (Math.floor(faceIndex/2) ===
                        Math.floor(this._planeClickStart[i]/2)) {
                        console.log('@@ click fulfilled for faceIndex:', faceIndex);
                        this.onPlaneClicked(faceIndex);
                    }
                }
                this._planeClickStart[i] = -1;
            });

            const planeCtx = _planeCanvas.getContext('2d');
            this.update = (t, dt) => {
                // console.log('@@ update(): hi');
                if (1) {
                    planeCtx.fillStyle = '#0cc';
                    planeCtx.fillRect(256*Math.random(), 256*Math.random(), 4, 20);
                    _plane.material.map.needsUpdate = true;
                }
                if (1) {
                    planeCtx.drawImage(_sigCanvas, 256, 0);
                    _plane.material.map.needsUpdate = true;
                }
            };

            // this.updateLoop(20);
            this.updateLoop(4); // debug
        }

        setupMouseInterface(onClick, onDrag) {
            let _mouseDragging = false;
            this.on('mouse-down', (x, y) => {
                _mouseDragging = true;
                console.log('@@ mouse down:', x, y);
            });
            this.on('mouse-move', (x, y) => {
                // console.log('@@ mouse move:');
                if (_mouseDragging) onDrag(x, y);
            });
            this.on('mouse-drag-end', (x, y) => {
                _mouseDragging = false;
                console.log('@@ mouse drag end:', x, y);
            });
            this.on('mouse-click', (x, y) => {
                _mouseDragging = false;
                console.log('@@ mouse click:', x, y);
                onClick(x, y);
            });
        }

        onPlaneClicked(faceIndex) {
            switch (faceIndex) {
                case 0: case 1: this.updateMarker('uleft'); break;
                case 2: case 3: this.updateMarker('uright'); break;
                case 4: case 5: this.updateMarker('lleft'); break;
                case 6: case 7: this.updateMarker('lright'); break;
                default: console.log('@@ woops');
            }
        }

        updateMarker(key) {
            const marker = this.selector.getObjectByName('marker');
            if (! marker) return;

            let markerPos = null;
            switch (key) {
                case 'uleft': markerPos = [-1, 0.05, 0.01]; break;
                case 'uright': markerPos = [-1+2, 0.05, 0.01]; break;
                case 'lleft': markerPos = [-1, 0.05-1, 0.01]; break;
                case 'lright': markerPos = [-1+2, 0.05-1, 0.01]; break;
                default: return; // woops
            }
            marker.visible = true;
            marker.position.set(...markerPos);
            this.render();
        }

        static createSelector(planeCanvas) {
            const selector = new THREE.Group();
            selector.position.set(0, 1, -0.4);

            const markerCanvas = document.createElement('canvas');
            markerCanvas.width = 256;
            markerCanvas.height = 128;
            const ctx = markerCanvas.getContext('2d');
            ctx.fillStyle = '#cc0';
            ctx.fillRect(0, 0, markerCanvas.width, markerCanvas.height);
            const marker = Threelet.Utils.createCanvasPlane(markerCanvas, 2, 0.1);
            marker.position.set(-1, 0.05, 0.01);
            marker.name = 'marker';
            marker.visible = false;
            selector.add(marker);

            const plane = Threelet.Utils.createCanvasPlane(planeCanvas, 4, 2, 2, 2);
            plane.material.transparent = true;
            plane.material.opacity = 0.9;
            plane.name = 'plane';
            selector.add(plane);

            return selector;
        }

        static createPlaneCanvas() {
            const planeCanvas = document.createElement('canvas');
            planeCanvas.width = 512;
            planeCanvas.height = 256;
            const ctxPlane = planeCanvas.getContext('2d');
            ctxPlane.fillStyle = '#000';
            ctxPlane.fillRect(0, 0, 512, 256);
            ctxPlane.fillStyle = '#ccc';
            ctxPlane.fillRect(0, 0, 256, 256);
            return planeCanvas;
        }
        static createSigObjects() {
            const sigCanvas = document.createElement('canvas');
            sigCanvas.width = 256;
            sigCanvas.height = 256;
            document.body.appendChild(sigCanvas);

            const penColor = 'rgb(200, 0, 200)';
            const dataTest = [
               [{x: 119, y: 85, color: penColor}, // stroke 0
               {x: 128, y: 83, color: penColor},
               {x: 136, y: 82, color: penColor},
               {x: 141, y: 82, color: penColor},
               {x: 128, y: 83, color: penColor}],
               [{x: 119, y: 185, color: penColor}, // stroke 1
               {x: 128, y: 183, color: penColor},
               {x: 136, y: 182, color: penColor},
               {x: 141, y: 182, color: penColor},
               {x: 128, y: 183, color: penColor}],
            ];
            console.log('@@ dataTest:', dataTest);

            const sigPad = new SignaturePad(sigCanvas, {
                minWidth: 10, // orig
                // minWidth: 4,
                // backgroundColor: 'rgba(255, 255, 255, 0)', // transparent
                backgroundColor: 'rgba(0, 0, 0, 255)', // debug
                penColor: penColor,
                onEnd: () => {
                    console.log('@@ onEnd(): hi');
                    const data = sigPad.toData();
                    console.log('@@ orig data:', data);

                    if (0) { // test restore
                        sigPad.clear();
                        sigPad.fromData(data);
                    }
                },
            });
            sigPad.fromData(dataTest);

            return [sigPad, sigCanvas];
        }
    }

    const viewer = new Viewer({
        canvas: document.getElementById("viewer"),
        // optAxes: false,
    });

    </script>
</body>
</html>
